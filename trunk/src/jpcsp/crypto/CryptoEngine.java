/*
This file is part of jpcsp.

Jpcsp is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Jpcsp is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Jpcsp.  If not, see <http://www.gnu.org/licenses/>.
 */

package jpcsp.crypto;

import java.nio.ByteBuffer;

public class CryptoEngine {

    // KIRK CMD1 AESCBC128-CMAC key.
    private static final int[] kirkAESKey0 = {0x98, 0xC9, 0x40, 0x97, 0x5C, 0x1D, 0x10, 0xE8, 0x7F, 0xE6, 0x0E, 0xA3, 0xFD, 0x03, 0xA8, 0xBA};

    // KIRK CMD4 and CMD7 AESCBC128 key table.
    private static final int[] kirkAESKey1 = {0x98, 0x02, 0xC4, 0xE6, 0xEC, 0x9E, 0x9E, 0x2F, 0xFC, 0x63, 0x4C, 0xE4, 0x2F, 0xBB, 0x46, 0x68};
    private static final int[] kirkAESKey2 = {0x99, 0x24, 0x4C, 0xD2, 0x58, 0xF5, 0x1B, 0xCB, 0xB0, 0x61, 0x9C, 0xA7, 0x38, 0x30, 0x07, 0x5F};
    private static final int[] kirkAESKey3 = {0x02, 0x25, 0xD7, 0xBA, 0x63, 0xEC, 0xB9, 0x4A, 0x9D, 0x23, 0x76, 0x01, 0xB3, 0xF6, 0xAC, 0x17};
    private static final int[] kirkAESKey4 = {0x84, 0x85, 0xC8, 0x48, 0x75, 0x08, 0x43, 0xBC, 0x9B, 0x9A, 0xEC, 0xA7, 0x9C, 0x7F, 0x60, 0x18};
    private static final int[] kirkAESKey5 = {0xB5, 0xB1, 0x6E, 0xDE, 0x23, 0xA9, 0x7B, 0x0E, 0xA1, 0x7C, 0xDB, 0xA2, 0xDC, 0xDE, 0xC4, 0x6E};
    private static final int[] kirkAESKey6 = {0xC8, 0x71, 0xFD, 0xB3, 0xBC, 0xC5, 0xD2, 0xF2, 0xE2, 0xD7, 0x72, 0x9D, 0xDF, 0x82, 0x68, 0x82};
    private static final int[] kirkAESKey7 = {0x0A, 0xBB, 0x33, 0x6C, 0x96, 0xD4, 0xCD, 0xD8, 0xCB, 0x5F, 0x4B, 0xE0, 0xBA, 0xDB, 0x9E, 0x03};
    private static final int[] kirkAESKey8 = {0x32, 0x29, 0x5B, 0xD5, 0xEA, 0xF7, 0xA3, 0x42, 0x16, 0xC8, 0x8E, 0x48, 0xFF, 0x50, 0xD3, 0x71};
    private static final int[] kirkAESKey9 = {0x46, 0xF2, 0x5E, 0x8E, 0x4D, 0x2A, 0xA5, 0x40, 0x73, 0x0B, 0xC4, 0x6E, 0x47, 0xEE, 0x6F, 0x0A};
    private static final int[] kirkAESKey10 = {0x5D, 0xC7, 0x11, 0x39, 0xD0, 0x19, 0x38, 0xBC, 0x02, 0x7F, 0xDD, 0xDC, 0xB0, 0x83, 0x7D, 0x9D};
    private static final int[] kirkAESKey11 = {0x12, 0x46, 0x8D, 0x7E, 0x1C, 0x42, 0x20, 0x9B, 0xBA, 0x54, 0x26, 0x83, 0x5E, 0xB0, 0x33, 0x03};
    private static final int[] kirkAESKey12 = {0xC4, 0x3B, 0xB6, 0xD6, 0x53, 0xEE, 0x67, 0x49, 0x3E, 0xA9, 0x5F, 0xBC, 0x0C, 0xED, 0x6F, 0x8A};
    private static final int[] kirkAESKey13 = {0x2C, 0xC3, 0xCF, 0x8C, 0x28, 0x78, 0xA5, 0xA6, 0x63, 0xE2, 0xAF, 0x2D, 0x71, 0x5E, 0x86, 0xBA};
    private static final int[] kirkAESKey14 = {0x0C, 0xFD, 0x67, 0x9A, 0xF9, 0xB4, 0x72, 0x4F, 0xD7, 0x8D, 0xD6, 0xE9, 0x96, 0x42, 0x28, 0x8B};
    private static final int[] kirkAESKey15 = {0xAF, 0xFE, 0x8E, 0xB1, 0x3D, 0xD1, 0x7E, 0xD8, 0x0A, 0x61, 0x24, 0x1C, 0x95, 0x92, 0x56, 0xB6};
    private static final int[] kirkAESKey16 = {0x1C, 0x9B, 0xC4, 0x90, 0xE3, 0x06, 0x64, 0x81, 0xFA, 0x59, 0xFD, 0xB6, 0x00, 0xBB, 0x28, 0x70};
    private static final int[] kirkAESKey17 = {0x11, 0x5A, 0x5D, 0x20, 0xD5, 0x3A, 0x8D, 0xD3, 0x9C, 0xC5, 0xAF, 0x41, 0x0F, 0x0F, 0x18, 0x6F};
    private static final int[] kirkAESKey18 = {0x9C, 0x9B, 0x13, 0x72, 0xF8, 0xC6, 0x40, 0xCF, 0x1C, 0x62, 0xF5, 0xD5, 0x92, 0xDD, 0xB5, 0x82};
    private static final int[] kirkAESKey19 = {0x03, 0xB3, 0x02, 0xE8, 0x5F, 0xF3, 0x81, 0xB1, 0x3B, 0x8D, 0xAA, 0x2A, 0x90, 0xFF, 0x5E, 0x61};

    // KIRK error values.
    private static final int PSP_KIRK_NOT_ENABLED = 1;
    private static final int PSP_KIRK_INVALID_MODE = 2;
    private static final int PSP_KIRK_INVALID_HEADER_HASH = 3;
    private static final int PSP_KIRK_INVALID_DATA_HASH = 4;
    private static final int PSP_KIRK_INVALID_SIG_CHECK = 5;
    private static final int PSP_KIRK_UNK1 = 6;
    private static final int PSP_KIRK_UNK2 = 7;
    private static final int PSP_KIRK_UNK3 = 8;
    private static final int PSP_KIRK_UNK4 = 9;
    private static final int PSP_KIRK_UNK5 = 10;
    private static final int PSP_KIRK_UNK6 = 11;
    private static final int PSP_KIRK_NOT_INIT = 12;
    private static final int PSP_KIRK_INVALID_OPERATION = 13;
    private static final int PSP_KIRK_INVALID_SEED = 14;
    private static final int PSP_KIRK_INVALID_SIZE = 15;
    private static final int PSP_KIRK_DATA_SIZE_IS_ZERO = 16;

    // KIRK commands.
    private static final int PSP_KIRK_CMD_DECRYPT_PRIVATE = 1;
    private static final int PSP_KIRK_CMD_ENCRYPT_IV_0 = 4;
    private static final int PSP_KIRK_CMD_ENCRYPT_IV_FUSE = 5;
    private static final int PSP_KIRK_CMD_ENCRYPT_IV_USER = 6;
    private static final int PSP_KIRK_CMD_DECRYPT_IV_0 = 7;
    private static final int PSP_KIRK_CMD_DECRYPT_IV_FUSE = 8;
    private static final int PSP_KIRK_CMD_DECRYPT_IV_USER = 9;
    private static final int PSP_KIRK_CMD_PRIV_SIG_CHECK = 10;
    private static final int PSP_KIRK_CMD_SHA1_HASH = 11;

    // KIRK command modes.
    private static final int PSP_KIRK_CMD_MODE_CMD1 = 1;
    private static final int PSP_KIRK_CMD_MODE_CMD2 = 2;
    private static final int PSP_KIRK_CMD_MODE_CMD3 = 3;
    private static final int PSP_KIRK_CMD_MODE_ENCRYPT_CBC = 4;
    private static final int PSP_KIRK_CMD_MODE_DECRYPT_CBC = 5;
    private boolean isCryptoEngineInit;

     // PRXDecrypter 16-byte tag keys.
    int[] keys260_0 = {0xC3, 0x24, 0x89, 0xD3, 0x80, 0x87, 0xB2, 0x4E, 0x4C, 0xD7, 0x49, 0xE4, 0x9D, 0x1D, 0x34, 0xD1};
    int[] keys260_1 = {0xF3, 0xAC, 0x6E, 0x7C, 0x04, 0x0A, 0x23, 0xE7, 0x0D, 0x33, 0xD8, 0x24, 0x73, 0x39, 0x2B, 0x4A};
    int[] keys260_2 = {0x72, 0xB4, 0x39, 0xFF, 0x34, 0x9B, 0xAE, 0x82, 0x30, 0x34, 0x4A, 0x1D, 0xA2, 0xD8, 0xB4, 0x3C};
    int[] keys280_0 = {0xCA, 0xFB, 0xBF, 0xC7, 0x50, 0xEA, 0xB4, 0x40, 0x8E, 0x44, 0x5C, 0x63, 0x53, 0xCE, 0x80, 0xB1};
    int[] keys280_1 = {0x40, 0x9B, 0xC6, 0x9B, 0xA9, 0xFB, 0x84, 0x7F, 0x72, 0x21, 0xD2, 0x36, 0x96, 0x55, 0x09, 0x74};
    int[] keys280_2 = {0x03, 0xA7, 0xCC, 0x4A, 0x5B, 0x91, 0xC2, 0x07, 0xFF, 0xFC, 0x26, 0x25, 0x1E, 0x42, 0x4B, 0xB5};
    int[] keys300_0 = {0x9F, 0x67, 0x1A, 0x7A, 0x22, 0xF3, 0x59, 0x0B, 0xAA, 0x6D, 0xA4, 0xC6, 0x8B, 0xD0, 0x03, 0x77};
    int[] keys300_1 = {0x15, 0x07, 0x63, 0x26, 0xDB, 0xE2, 0x69, 0x34, 0x56, 0x08, 0x2A, 0x93, 0x4E, 0x4B, 0x8A, 0xB2};
    int[] keys300_2 = {0x56, 0x3B, 0x69, 0xF7, 0x29, 0x88, 0x2F, 0x4C, 0xDB, 0xD5, 0xDE, 0x80, 0xC6, 0x5C, 0xC8, 0x73};
    int[] keys303_0 = {0x7b, 0xa1, 0xe2, 0x5a, 0x91, 0xb9, 0xd3, 0x13, 0x77, 0x65, 0x4a, 0xb7, 0xc2, 0x8a, 0x10, 0xaf};
    int[] keys310_0 = {0xa2, 0x41, 0xe8, 0x39, 0x66, 0x5b, 0xfa, 0xbb, 0x1b, 0x2d, 0x6e, 0x0e, 0x33, 0xe5, 0xd7, 0x3f};
    int[] keys310_1 = {0xA4, 0x60, 0x8F, 0xAB, 0xAB, 0xDE, 0xA5, 0x65, 0x5D, 0x43, 0x3A, 0xD1, 0x5E, 0xC3, 0xFF, 0xEA};
    int[] keys310_2 = {0xE7, 0x5C, 0x85, 0x7A, 0x59, 0xB4, 0xE3, 0x1D, 0xD0, 0x9E, 0xCE, 0xC2, 0xD6, 0xD4, 0xBD, 0x2B};
    int[] keys310_3 = {0x2E, 0x00, 0xF6, 0xF7, 0x52, 0xCF, 0x95, 0x5A, 0xA1, 0x26, 0xB4, 0x84, 0x9B, 0x58, 0x76, 0x2F};
    int[] keys330_0 = {0x3B, 0x9B, 0x1A, 0x56, 0x21, 0x80, 0x14, 0xED, 0x8E, 0x8B, 0x08, 0x42, 0xFA, 0x2C, 0xDC, 0x3A};
    int[] keys330_1 = {0xE8, 0xBE, 0x2F, 0x06, 0xB1, 0x05, 0x2A, 0xB9, 0x18, 0x18, 0x03, 0xE3, 0xEB, 0x64, 0x7D, 0x26};
    int[] keys330_2 = {0xAB, 0x82, 0x25, 0xD7, 0x43, 0x6F, 0x6C, 0xC1, 0x95, 0xC5, 0xF7, 0xF0, 0x63, 0x73, 0x3F, 0xE7};
    int[] keys330_3 = {0xA8, 0xB1, 0x47, 0x77, 0xDC, 0x49, 0x6A, 0x6F, 0x38, 0x4C, 0x4D, 0x96, 0xBD, 0x49, 0xEC, 0x9B};
    int[] keys330_4 = {0xEC, 0x3B, 0xD2, 0xC0, 0xFA, 0xC1, 0xEE, 0xB9, 0x9A, 0xBC, 0xFF, 0xA3, 0x89, 0xF2, 0x60, 0x1F};
    int[] demokeys_280 = {0x12, 0x99, 0x70, 0x5E, 0x24, 0x07, 0x6C, 0xD0, 0x2D, 0x06, 0xFE, 0x7E, 0xB3, 0x0C, 0x11, 0x26};
    int[] demokeys_3XX_1 = {0x47, 0x05, 0xD5, 0xE3, 0x56, 0x1E, 0x81, 0x9B, 0x09, 0x2F, 0x06, 0xDB, 0x6B, 0x12, 0x92, 0xE0};
    int[] demokeys_3XX_2 = {0xF6, 0x62, 0x39, 0x6E, 0x26, 0x22, 0x4D, 0xCA, 0x02, 0x64, 0x16, 0x99, 0x7B, 0x9A, 0xE7, 0xB8};
    int[] ebootbin_271_new = {0xF4, 0xAE, 0xF4, 0xE1, 0x86, 0xDD, 0xD2, 0x9C, 0x7C, 0xC5, 0x42, 0xA6, 0x95, 0xA0, 0x83, 0x88};
    int[] ebootbin_280_new = {0xB8, 0x8C, 0x45, 0x8B, 0xB6, 0xE7, 0x6E, 0xB8, 0x51, 0x59, 0xA6, 0x53, 0x7C, 0x5E, 0x86, 0x31};
    int[] ebootbin_300_new = {0xED, 0x10, 0xE0, 0x36, 0xC4, 0xFE, 0x83, 0xF3, 0x75, 0x70, 0x5E, 0xF6, 0xA4, 0x40, 0x05, 0xF7};
    int[] ebootbin_310_new = {0x5C, 0x77, 0x0C, 0xBB, 0xB4, 0xC2, 0x4F, 0xA2, 0x7E, 0x3B, 0x4E, 0xB4, 0xB4, 0xC8, 0x70, 0xAF};
    int[] gameshare_260_271 = {0xF9, 0x48, 0x38, 0x0C, 0x96, 0x88, 0xA7, 0x74, 0x4F, 0x65, 0xA0, 0x54, 0xC2, 0x76, 0xD9, 0xB8};
    int[] gameshare_280 = {0x2D, 0x86, 0x77, 0x3A, 0x56, 0xA4, 0x4F, 0xDD, 0x3C, 0x16, 0x71, 0x93, 0xAA, 0x8E, 0x11, 0x43};
    int[] gameshare_300 = {0x78, 0x1A, 0xD2, 0x87, 0x24, 0xBD, 0xA2, 0x96, 0x18, 0x3F, 0x89, 0x36, 0x72, 0x90, 0x92, 0x85};
    int[] gameshare_310 = {0xC9, 0x7D, 0x3E, 0x0A, 0x54, 0x81, 0x6E, 0xC7, 0x13, 0x74, 0x99, 0x74, 0x62, 0x18, 0xE7, 0xDD};
    int[] keys360_0 = {0x3C, 0x2B, 0x51, 0xD4, 0x2D, 0x85, 0x47, 0xDA, 0x2D, 0xCA, 0x18, 0xDF, 0xFE, 0x54, 0x09, 0xED};
    int[] keys360_1 = {0x31, 0x1F, 0x98, 0xD5, 0x7B, 0x58, 0x95, 0x45, 0x32, 0xAB, 0x3A, 0xE3, 0x89, 0x32, 0x4B, 0x34};
    int[] keys370_0 = {0x26, 0x38, 0x0A, 0xAC, 0xA5, 0xD8, 0x74, 0xD1, 0x32, 0xB7, 0x2A, 0xBF, 0x79, 0x9E, 0x6D, 0xDB};
    int[] keys370_1 = {0x53, 0xE7, 0xAB, 0xB9, 0xC6, 0x4A, 0x4B, 0x77, 0x92, 0x17, 0xB5, 0x74, 0x0A, 0xDA, 0xA9, 0xEA};
    int[] keys370_2 = {0x71, 0x10, 0xF0, 0xA4, 0x16, 0x14, 0xD5, 0x93, 0x12, 0xFF, 0x74, 0x96, 0xDF, 0x1F, 0xDA, 0x89};
    int[] oneseg_310 = {0xC7, 0x27, 0x72, 0x85, 0xAB, 0xA7, 0xF7, 0xF0, 0x4C, 0xC1, 0x86, 0xCC, 0xE3, 0x7F, 0x17, 0xCA};
    int[] oneseg_300 = {0x76, 0x40, 0x9E, 0x08, 0xDB, 0x9B, 0x3B, 0xA1, 0x47, 0x8A, 0x96, 0x8E, 0xF3, 0xF7, 0x62, 0x92};
    int[] oneseg_280 = {0x23, 0xDC, 0x3B, 0xB5, 0xA9, 0x82, 0xD6, 0xEA, 0x63, 0xA3, 0x6E, 0x2B, 0x2B, 0xE9, 0xE1, 0x54};
    int[] oneseg_260_271 = {0x22, 0x43, 0x57, 0x68, 0x2F, 0x41, 0xCE, 0x65, 0x4C, 0xA3, 0x7C, 0xC6, 0xC4, 0xAC, 0xF3, 0x60};
    int[] oneseg_slim = {0x12, 0x57, 0x0D, 0x8A, 0x16, 0x6D, 0x87, 0x06, 0x03, 0x7D, 0xC8, 0x8B, 0x62, 0xA3, 0x32, 0xA9};
    int[] ms_app_main = {0x1E, 0x2E, 0x38, 0x49, 0xDA, 0xD4, 0x16, 0x08, 0x27, 0x2E, 0xF3, 0xBC, 0x37, 0x75, 0x80, 0x93};
    int[] keys390_0 = {0x45, 0xEF, 0x5C, 0x5D, 0xED, 0x81, 0x99, 0x84, 0x12, 0x94, 0x8F, 0xAB, 0xE8, 0x05, 0x6D, 0x7D};
    int[] keys390_1 = {0x70, 0x1B, 0x08, 0x25, 0x22, 0xA1, 0x4D, 0x3B, 0x69, 0x21, 0xF9, 0x71, 0x0A, 0xA8, 0x41, 0xA9};
    int[] keys500_0 = {0xEB, 0x1B, 0x53, 0x0B, 0x62, 0x49, 0x32, 0x58, 0x1F, 0x83, 0x0A, 0xF4, 0x99, 0x3D, 0x75, 0xD0};
    int[] keys500_1 = {0xBA, 0xE2, 0xA3, 0x12, 0x07, 0xFF, 0x04, 0x1B, 0x64, 0xA5, 0x11, 0x85, 0xF7, 0x2F, 0x99, 0x5B};
    int[] keys500_2 = {0x2C, 0x8E, 0xAF, 0x1D, 0xFF, 0x79, 0x73, 0x1A, 0xAD, 0x96, 0xAB, 0x09, 0xEA, 0x35, 0x59, 0x8B};
    int[] keys500_c = {0xA3, 0x5D, 0x51, 0xE6, 0x56, 0xC8, 0x01, 0xCA, 0xE3, 0x77, 0xBF, 0xCD, 0xFF, 0x24, 0xDA, 0x4D};
    int[] keys505_a = {0x7B, 0x94, 0x72, 0x27, 0x4C, 0xCC, 0x54, 0x3B, 0xAE, 0xDF, 0x46, 0x37, 0xAC, 0x01, 0x4D, 0x87};
    int[] keys505_0 = {0x2E, 0x8E, 0x97, 0xA2, 0x85, 0x42, 0x70, 0x73, 0x18, 0xDA, 0xA0, 0x8A, 0xF8, 0x62, 0xA2, 0xB0};
    int[] keys505_1 = {0x58, 0x2A, 0x4C, 0x69, 0x19, 0x7B, 0x83, 0x3D, 0xD2, 0x61, 0x61, 0xFE, 0x14, 0xEE, 0xAA, 0x11};
    int[] keys02G_E = {0x9D, 0x09, 0xFD, 0x20, 0xF3, 0x8F, 0x10, 0x69, 0x0D, 0xB2, 0x6F, 0x00, 0xCC, 0xC5, 0x51, 0x2E};
    int[] keys03G_E = {0x4F, 0x44, 0x5C, 0x62, 0xB3, 0x53, 0xC4, 0x30, 0xFC, 0x3A, 0xA4, 0x5B, 0xEC, 0xFE, 0x51, 0xEA};
    int[] key_D91609F0 = {0xD0, 0x36, 0x12, 0x75, 0x80, 0x56, 0x20, 0x43, 0xC4, 0x30, 0x94, 0x3E, 0x1C, 0x75, 0xD1, 0xBF};
    int[] key_D9160AF0 = {0x10, 0xA9, 0xAC, 0x16, 0xAE, 0x19, 0xC0, 0x7E, 0x3B, 0x60, 0x77, 0x86, 0x01, 0x6F, 0xF2, 0x63};
    int[] key_D9160BF0 = {0x83, 0x83, 0xF1, 0x37, 0x53, 0xD0, 0xBE, 0xFC, 0x8D, 0xA7, 0x32, 0x52, 0x46, 0x0A, 0xC2, 0xC2};
    int[] key_D91611F0 = {0x61, 0xB0, 0xC0, 0x58, 0x71, 0x57, 0xD9, 0xFA, 0x74, 0x67, 0x0E, 0x5C, 0x7E, 0x6E, 0x95, 0xB9};
    int[] key_D91612F0 = {0x9E, 0x20, 0xE1, 0xCD, 0xD7, 0x88, 0xDE, 0xC0, 0x31, 0x9B, 0x10, 0xAF, 0xC5, 0xB8, 0x73, 0x23};
    int[] key_D91613F0 = {0xEB, 0xFF, 0x40, 0xD8, 0xB4, 0x1A, 0xE1, 0x66, 0x91, 0x3B, 0x8F, 0x64, 0xB6, 0xFC, 0xB7, 0x12};
    int[] key_D91614F0 = {0xFD, 0xF7, 0xB7, 0x3C, 0x9F, 0xD1, 0x33, 0x95, 0x11, 0xB8, 0xB5, 0xBB, 0x54, 0x23, 0x73, 0x85};
    int[] key_2E5E10F0 = {0x9D, 0x5C, 0x5B, 0xAF, 0x8C, 0xD8, 0x69, 0x7E, 0x51, 0x9F, 0x70, 0x96, 0xE6, 0xD5, 0xC4, 0xE8};
    int[] key_2E5E12F0 = {0x8A, 0x7B, 0xC9, 0xD6, 0x52, 0x58, 0x88, 0xEA, 0x51, 0x83, 0x60, 0xCA, 0x16, 0x79, 0xE2, 0x07};
    int[] key_2E5E13F0 = {0xFF, 0xA4, 0x68, 0xC3, 0x31, 0xCA, 0xB7, 0x4C, 0xF1, 0x23, 0xFF, 0x01, 0x65, 0x3D, 0x26, 0x36};
    int[] keys600_u1_457B0BF0 = {0x7B, 0x94, 0x72, 0x27, 0x4C, 0xCC, 0x54, 0x3B, 0xAE, 0xDF, 0x46, 0x37, 0xAC, 0x01, 0x4D, 0x87};
    int[] keys600_u1_457B0CF0 = {0xAC, 0x34, 0xBA, 0xB1, 0x97, 0x8D, 0xAE, 0x6F, 0xBA, 0xE8, 0xB1, 0xD6, 0xDF, 0xDF, 0xF1, 0xA2};
    int[] keys05G_E = {0x5D, 0xAA, 0x72, 0xF2, 0x26, 0x60, 0x4D, 0x1C, 0xE7, 0x2D, 0xC8, 0xA3, 0x2F, 0x79, 0xC5, 0x54};
    int[] keys570_5k = {0x6D, 0x72, 0xA4, 0xBA, 0x7F, 0xBF, 0xD1, 0xF1, 0xA9, 0xF3, 0xBB, 0x07, 0x1B, 0xC0, 0xB3, 0x66};
    int[] keys620_0 = {0xD6, 0xBD, 0xCE, 0x1E, 0x12, 0xAF, 0x9A, 0xE6, 0x69, 0x30, 0xDE, 0xDA, 0x88, 0xB8, 0xFF, 0xFB};
    int[] keys620_1 = {0x1D, 0x13, 0xE9, 0x50, 0x04, 0x73, 0x3D, 0xD2, 0xE1, 0xDA, 0xB9, 0xC1, 0xE6, 0x7B, 0x25, 0xA7};
    int[] keys620_3 = {0xA3, 0x5D, 0x51, 0xE6, 0x56, 0xC8, 0x01, 0xCA, 0xE3, 0x77, 0xBF, 0xCD, 0xFF, 0x24, 0xDA, 0x4D};
    int[] keys620_e = {0xB1, 0xB3, 0x7F, 0x76, 0xC3, 0xFB, 0x88, 0xE6, 0xF8, 0x60, 0xD3, 0x35, 0x3C, 0xA3, 0x4E, 0xF3};
    int[] keys620_5 = {0xF1, 0xBC, 0x17, 0x07, 0xAE, 0xB7, 0xC8, 0x30, 0xD8, 0x34, 0x9D, 0x40, 0x6A, 0x8E, 0xDF, 0x4E};
    int[] keys620_5k = {0x41, 0x8A, 0x35, 0x4F, 0x69, 0x3A, 0xDF, 0x04, 0xFD, 0x39, 0x46, 0xA2, 0x5C, 0x2D, 0xF2, 0x21};
    int[] keys620_5v = {0xF2, 0x8F, 0x75, 0xA7, 0x31, 0x91, 0xCE, 0x9E, 0x75, 0xBD, 0x27, 0x26, 0xB4, 0xB4, 0x0C, 0x32};
    int[] key_21C0 = {0x6A, 0x19, 0x71, 0xF3, 0x18, 0xDE, 0xD3, 0xA2, 0x6D, 0x3B, 0xDE, 0xC7, 0xBE, 0x98, 0xE2, 0x4C};
    int[] key_2250 = {0x50, 0xCC, 0x03, 0xAC, 0x3F, 0x53, 0x1A, 0xFA, 0x0A, 0xA4, 0x34, 0x23, 0x86, 0x61, 0x7F, 0x97};
    int[] key_22E0 = {0x66, 0x0F, 0xCB, 0x3B, 0x30, 0x75, 0xE3, 0x10, 0x0A, 0x95, 0x65, 0xC7, 0x3C, 0x93, 0x87, 0x22};
    int[] key_2D80 = {0x40, 0x02, 0xC0, 0xBF, 0x20, 0x02, 0xC0, 0xBF, 0x5C, 0x68, 0x2B, 0x95, 0x5F, 0x40, 0x7B, 0xB8};
    int[] key_2D90 = {0x55, 0x19, 0x35, 0x10, 0x48, 0xD8, 0x2E, 0x46, 0xA8, 0xB1, 0x47, 0x77, 0xDC, 0x49, 0x6A, 0x6F};
    int[] key_2DA8 = {0x80, 0x02, 0xC0, 0xBF, 0x00, 0x0A, 0xC0, 0xBF, 0x40, 0x03, 0xC0, 0xBF, 0x40, 0x00, 0x00, 0x00};
    int[] key_2DB8 = {0x4C, 0x2D, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0xB8, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    int[] key_4c9484f0 = {0x36, 0xB0, 0xDC, 0xFC, 0x59, 0x2A, 0x95, 0x1D, 0x80, 0x2D, 0x80, 0x3F, 0xCD, 0x30, 0xA0, 0x1B,};
    int[] key_457b80f0 = {0xd4, 0x35, 0x18, 0x02, 0x29, 0x68, 0xfb, 0xa0, 0x6a, 0xa9, 0xa5, 0xed, 0x78, 0xfd, 0x2e, 0x9d};
    int[] key_380280f0 = {0x97, 0x09, 0x12, 0xD3, 0xDB, 0x02, 0xBD, 0xD8, 0xE7, 0x74, 0x51, 0xFE, 0xF0, 0xEA, 0x6C, 0x5C,};

    private class TAG_INFO {
        private static final int size = 21;
        int tag; // 4 byte value at offset 0xD0 in the PRX file
        int[] key; // 16 bytes keys
        int code; // code for scramble

        public TAG_INFO(int tag, int[] key, int code) {
            this.tag = tag;
            this.key = key;
            this.code = code;
        }
    }

    private TAG_INFO g_tagInfo[] = {
        new TAG_INFO(0x380280f0, key_380280f0, 0x5A),
        new TAG_INFO(0x4C9484F0, key_4c9484f0, 0x43),
        new TAG_INFO(0x457b80f0, key_457b80f0, 0x5B),
        new TAG_INFO(0x4C940FF0, key_2DA8, 0x43),
        new TAG_INFO(0x4467415D, key_22E0, 0x59),
        new TAG_INFO(0x00000000, key_21C0, 0x42),
        new TAG_INFO(0x01000000, key_2250, 0x43),
        new TAG_INFO(0x380228F0, keys620_5v, 0x5A),
        new TAG_INFO(0x4C942AF0, keys620_5k, 0x43),
        new TAG_INFO(0x4C9428F0, keys620_5, 0x43),
        new TAG_INFO(0x4C9429F0, keys570_5k, 0x43),
        new TAG_INFO(0x4C941DF0, keys620_1, 0x43),
        new TAG_INFO(0x4C941CF0, keys620_0, 0x43),
        new TAG_INFO(0x457B1EF0, keys620_3, 0x5B),
        new TAG_INFO(0x457B0BF0, keys600_u1_457B0BF0, 0x5B),
        new TAG_INFO(0x457B0CF0, keys600_u1_457B0CF0, 0x5B),
        new TAG_INFO(0x4C9419F0, keys500_1, 0x43),
        new TAG_INFO(0x4C9418F0, keys500_0, 0x43),
        new TAG_INFO(0x4C941FF0, keys500_2, 0x43),
        new TAG_INFO(0x4C9417F0, keys500_1, 0x43),
        new TAG_INFO(0x4C9416F0, keys500_0, 0x43),
        new TAG_INFO(0x4C9414F0, keys390_0, 0x43),
        new TAG_INFO(0x4C9415F0, keys390_1, 0x43),
        new TAG_INFO(0xD82310F0, keys02G_E, 0x51),
        new TAG_INFO(0xD8231EF0, keys03G_E, 0x51),
        new TAG_INFO(0xD82328F0, keys05G_E, 0x51),
        new TAG_INFO(0x4C9412F0, keys370_0, 0x43),
        new TAG_INFO(0x4C9413F0, keys370_1, 0x43),
        new TAG_INFO(0x457B10F0, keys370_2, 0x5B),
        new TAG_INFO(0x4C940DF0, keys360_0, 0x43),
        new TAG_INFO(0x4C9410F0, keys360_1, 0x43),
        new TAG_INFO(0x4C940BF0, keys330_0, 0x43),
        new TAG_INFO(0x457B0AF0, keys330_1, 0x5B),
        new TAG_INFO(0x38020AF0, keys330_2, 0x5A),
        new TAG_INFO(0x4C940AF0, keys330_3, 0x43),
        new TAG_INFO(0x4C940CF0, keys330_4, 0x43),
        new TAG_INFO(0xcfef09f0, keys310_0, 0x62),
        new TAG_INFO(0x457b08f0, keys310_1, 0x5B),
        new TAG_INFO(0x380208F0, keys310_2, 0x5A),
        new TAG_INFO(0xcfef08f0, keys310_3, 0x62),
        new TAG_INFO(0xCFEF07F0, keys303_0, 0x62),
        new TAG_INFO(0xCFEF06F0, keys300_0, 0x62),
        new TAG_INFO(0x457B06F0, keys300_1, 0x5B),
        new TAG_INFO(0x380206F0, keys300_2, 0x5A),
        new TAG_INFO(0xCFEF05F0, keys280_0, 0x62),
        new TAG_INFO(0x457B05F0, keys280_1, 0x5B),
        new TAG_INFO(0x380205F0, keys280_2, 0x5A),
        new TAG_INFO(0x16D59E03, keys260_0, 0x62),
        new TAG_INFO(0x76202403, keys260_1, 0x5B),
        new TAG_INFO(0x0F037303, keys260_2, 0x5A),
        new TAG_INFO(0x457B28F0, keys620_e, 0x5B),
        new TAG_INFO(0xADF305F0, demokeys_280, 0x60),
        new TAG_INFO(0xADF306F0, demokeys_3XX_1, 0x60),
        new TAG_INFO(0xADF308F0, demokeys_3XX_2, 0x60),
        new TAG_INFO(0x8004FD03, ebootbin_271_new, 0x5D),
        new TAG_INFO(0xD91605F0, ebootbin_280_new, 0x5D),
        new TAG_INFO(0xD91606F0, ebootbin_300_new, 0x5D),
        new TAG_INFO(0xD91608F0, ebootbin_310_new, 0x5D),
        new TAG_INFO(0xD91609F0, key_D91609F0, 0x5D),
        new TAG_INFO(0x2E5E10F0, key_2E5E10F0, 0x48),
        new TAG_INFO(0x2E5E12F0, key_2E5E12F0, 0x48),
        new TAG_INFO(0x2E5E12F0, key_2E5E13F0, 0x48),
        new TAG_INFO(0xD9160AF0, key_D9160AF0, 0x5D),
        new TAG_INFO(0xD9160BF0, key_D9160BF0, 0x5D),
        new TAG_INFO(0xD91611F0, key_D91611F0, 0x5D),
        new TAG_INFO(0xD91612F0, key_D91612F0, 0x5D),
        new TAG_INFO(0xD91613F0, key_D91613F0, 0x5D),
        new TAG_INFO(0xD91614F0, key_D91614F0, 0x5D),
        new TAG_INFO(0x0A35EA03, gameshare_260_271, 0x5E),
        new TAG_INFO(0x7B0505F0, gameshare_280, 0x5E),
        new TAG_INFO(0x7B0506F0, gameshare_300, 0x5E),
        new TAG_INFO(0x7B0508F0, gameshare_310, 0x5E),
        new TAG_INFO(0x279D08F0, oneseg_310, 0x61),
        new TAG_INFO(0x279D06F0, oneseg_300, 0x61),
        new TAG_INFO(0x279D05F0, oneseg_280, 0x61),
        new TAG_INFO(0xD66DF703, oneseg_260_271, 0x61),
        new TAG_INFO(0x279D10F0, oneseg_slim, 0x61),
        new TAG_INFO(0x3C2A08F0, ms_app_main, 0x67),};

    private class SHA1Header {

        private int dataSize;
        private byte[] data;

        public SHA1Header(ByteBuffer buf) {
            dataSize = buf.getInt();
        }

        private void readData(ByteBuffer buf, int size) {
            data = new byte[size];
            buf.get(data, 0, size);
        }
    }

    private class AES128CBCHeader {

        private int mode;
        private int unk1;
        private int unk2;
        private int keySeed;
        private int dataSize;

        public AES128CBCHeader(ByteBuffer buf) {
            mode = buf.getInt();
            unk1 = buf.getInt();
            unk2 = buf.getInt();
            keySeed = buf.getInt();
            dataSize = buf.getInt();
        }
    }

    private class AES128CMACHeader {

        private byte[] AES128Key = new byte[16];
        private byte[] CMACKey = new byte[16];
        private byte[] CMACHeaderHash = new byte[16];
        private byte[] CMACDataHash = new byte[16];
        private byte[] unk1 = new byte[32];
        private int mode;
        private byte[] unk2 = new byte[12];
        private int dataSize;
        private int dataOffset;
        private byte[] unk3 = new byte[8];
        private byte[] unk4 = new byte[16];

        public AES128CMACHeader(ByteBuffer buf) {
            buf.get(AES128Key, 0, 16);
            buf.get(CMACKey, 0, 16);
            buf.get(CMACHeaderHash, 0, 16);
            buf.get(CMACDataHash, 0, 16);
            buf.get(unk1, 0, 32);
            mode = buf.getInt();
            buf.get(unk2, 0, 12);
            dataSize = buf.getInt();
            dataOffset = buf.getInt();
            buf.get(unk3, 0, 8);
            buf.get(unk4, 0, 16);
        }
    }

    public CryptoEngine() {
        isCryptoEngineInit = true;
    }

    private int[] getAESKeyFromSeed(int seed) {
        switch (seed) {
            case (0x03):
                return kirkAESKey1;
            case (0x04):
                return kirkAESKey2;
            case (0x05):
                return kirkAESKey3;
            case (0x0C):
                return kirkAESKey4;
            case (0x0D):
                return kirkAESKey5;
            case (0x0E):
                return kirkAESKey6;
            case (0x0F):
                return kirkAESKey7;
            case (0x10):
                return kirkAESKey8;
            case (0x11):
                return kirkAESKey8;
            case (0x12):
                return kirkAESKey10;
            case (0x38):
                return kirkAESKey11;
            case (0x39):
                return kirkAESKey12;
            case (0x3A):
                return kirkAESKey13;
            case (0x4B):
                return kirkAESKey14;
            case (0x53):
                return kirkAESKey15;
            case (0x57):
                return kirkAESKey16;
            case (0x5D):
                return kirkAESKey17;
            case (0x63):
                return kirkAESKey18;
            case (0x64):
                return kirkAESKey19;
            default:
                return null;
        }
    }

    // Decrypt with AESCBC128-CMAC header and sig check.
    private int executeKIRKCmd1(ByteBuffer out, ByteBuffer in, int size) {
        // Return an error if the crypto engine hasn't been initialized.
        if (!isCryptoEngineInit) {
            return PSP_KIRK_NOT_INIT;
        }

        // Copy the input for sig check.
        ByteBuffer sigIn = in.duplicate();

        // Read in the CMD1 format header.
        AES128CMACHeader header = new AES128CMACHeader(in);

        if (header.mode != PSP_KIRK_CMD_MODE_CMD1) {
            return PSP_KIRK_INVALID_MODE;  // Only valid for mode CMD1.
        }

        // Start AES128 processing.
        AES128 aes = new AES128();
        byte[] iv = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        // Convert the AES CMD1 key into a real byte array for SecretKeySpec.
        byte[] k = new byte[16];
        for (int i = 0; i < kirkAESKey0.length; i++) {
            k[i] = (byte) kirkAESKey0[i];
        }

        // Decrypt and extract the new AES and CMAC keys from the top of the data.
        byte[] encryptedKeys = new byte[32];
        byte[] decryptedKeys = new byte[32];
        for (int i = 0; i < 16; i++) {
            encryptedKeys[i] = (byte) header.AES128Key[i];
        }
        for (int i = 0; i < 16; i++) {
            encryptedKeys[i + 16] = (byte) header.CMACKey[i];
        }
        decryptedKeys = aes.decryptCBC(encryptedKeys, k, iv);

        // Check for a valid signature.
        int sigCheck = executeKIRKCmd10(sigIn, size);

        // Get the newly decrypted AES key and proceed with the
        // full data decryption.
        if (decryptedKeys != null) {
            byte[] aesBuf = new byte[16];
            for (int i = 0; i < 16; i++) {
                aesBuf[i] = decryptedKeys[i];
            }
            // Skip the CMD1 header.
            int headerSize = 0x90;
            int headerOffset = 0x40;

            // Extract the final ELF params.
            int elfDataSize = Integer.reverseBytes(header.dataSize);
            int elfDataOffset = Integer.reverseBytes(header.dataOffset);

            // Decrypt all the ELF data.
            byte[] inBuf = new byte[elfDataSize];
            for (int i = 0; i < elfDataSize; i++) {
                inBuf[i] = in.array()[elfDataOffset + headerOffset + headerSize + i];
            }
            byte[] outBuf = new byte[elfDataSize];
            outBuf = aes.decryptCBC(inBuf, aesBuf, iv);

            out.clear();
            out.put(outBuf);
            out.limit(elfDataSize);
            in.clear();

            return 0;
        } else {
            // Only return the sig check result if the keys are invalid
            // to allow skipping the CMAC comparision.
            // TODO: Trace why the CMAC hashes aren't matching.
            return sigCheck;
        }
    }

    // Encrypt with AESCBC128 using keys from table.
    private int executeKIRKCmd4(ByteBuffer out, ByteBuffer in, int size) {
        // Return an error if the crypto engine hasn't been initialized.
        if (!isCryptoEngineInit) {
            return PSP_KIRK_NOT_INIT;
        }

        // Read in the CMD4 format header.
        AES128CBCHeader header = new AES128CBCHeader(in);

        if (header.mode != PSP_KIRK_CMD_MODE_ENCRYPT_CBC) {
            return PSP_KIRK_INVALID_MODE;  // Only valid for mode ENCRYPT_CBC.
        }

        if (header.dataSize == 0) {
            return PSP_KIRK_DATA_SIZE_IS_ZERO;
        }

        int[] key = getAESKeyFromSeed(header.keySeed);
        if (key == null) {
            return PSP_KIRK_INVALID_SIZE; // Dummy.
        }

        byte[] encKey = new byte[16];
        for (int i = 0; i < encKey.length; i++) {
            encKey[i] = (byte) key[i];
        }

        AES128 aes = new AES128();
        byte[] iv = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        byte[] inBuf = new byte[size];
        byte[] outBuf = new byte[size];
        in.get(inBuf, 0, size);
        outBuf = aes.encryptCBC(inBuf, encKey, iv);

        out.clear();
        out.put(outBuf);
        in.clear();

        return 0;
    }

    // Decrypt with AESCBC128 using keys from table.
    private int executeKIRKCmd7(ByteBuffer out, ByteBuffer in, int size) {
        // Return an error if the crypto engine hasn't been initialized.
        if (!isCryptoEngineInit) {
            return PSP_KIRK_NOT_INIT;
        }

        // Read in the CMD7 format header.
        AES128CBCHeader header = new AES128CBCHeader(in);

        if (header.mode != PSP_KIRK_CMD_MODE_DECRYPT_CBC) {
            return PSP_KIRK_INVALID_MODE;  // Only valid for mode DECRYPT_CBC.
        }

        if (header.dataSize == 0) {
            return PSP_KIRK_DATA_SIZE_IS_ZERO;
        }

        int[] key = getAESKeyFromSeed(header.keySeed);
        if (key == null) {
            return PSP_KIRK_INVALID_SIZE; // Dummy.
        }

        byte[] decKey = new byte[16];
        for (int i = 0; i < decKey.length; i++) {
            decKey[i] = (byte) key[i];
        }

        AES128 aes = new AES128();
        byte[] iv = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        byte[] inBuf = new byte[size];
        byte[] outBuf = new byte[size];
        in.get(inBuf, 0, size);
        outBuf = aes.decryptCBC(inBuf, decKey, iv);

        out.clear();
        out.put(outBuf);
        in.clear();

        return 0;
    }

    // CMAC Sig check.
    private int executeKIRKCmd10(ByteBuffer in, int size) {
        // Return an error if the crypto engine hasn't been initialized.
        if (!isCryptoEngineInit) {
            return PSP_KIRK_NOT_INIT;
        }

        // Read in the CMD10 format header.
        AES128CMACHeader header = new AES128CMACHeader(in);
        if ((header.mode != PSP_KIRK_CMD_MODE_CMD1) &&
                (header.mode != PSP_KIRK_CMD_MODE_CMD2) &&
                (header.mode != PSP_KIRK_CMD_MODE_CMD3)) {
            return PSP_KIRK_INVALID_MODE;  // Only valid for modes CMD1, CMD2 and CMD3.
        }

        if (header.dataSize == 0) {
            return PSP_KIRK_DATA_SIZE_IS_ZERO;
        }

        AES128 aes = new AES128();
        byte[] iv = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        // Convert the AES CMD1 key into a real byte array.
        byte[] k = new byte[16];
        for (int i = 0; i < kirkAESKey0.length; i++) {
            k[i] = (byte) (kirkAESKey0[i] & 0xFF);
        }

        // Decrypt and extract the new AES and CMAC keys from the top of the data.
        byte[] encryptedKeys = new byte[32];
        byte[] decryptedKeys = new byte[32];
        for (int i = 0; i < 16; i++) {
            encryptedKeys[i] = (byte) header.AES128Key[i];
        }
        for (int i = 0; i < 16; i++) {
            encryptedKeys[i + 16] = (byte) header.CMACKey[i];
        }
        decryptedKeys = aes.decryptCBC(encryptedKeys, k, iv);

        byte[] cmacHeaderHash = new byte[16];
        byte[] cmacDataHash = new byte[16];

        byte[] cmacBuf = new byte[16];
        for (int i = 0; i < 16; i++) {
            cmacBuf[i] = decryptedKeys[i + 16];
        }

        // Position the buffer at the CMAC keys offset.
        byte[] inBuf = new byte[in.capacity() - 0x60];
        for (int i = 0; i < inBuf.length; i++) {
            inBuf[i] = in.array()[i + 0x60];
        }

        // Calculate CMAC header hash.
        aes.doInitCMAC(cmacBuf);
        aes.doUpdateCMAC(inBuf, 0, 0x30);
        cmacHeaderHash = aes.doFinalCMAC();

        int blockSize = Integer.reverseBytes(header.dataSize);
        if ((blockSize % 16) != 0) {
            blockSize += (16 - (blockSize % 16));
        }

        // Calculate CMAC data hash.
        aes.doInitCMAC(cmacBuf);
        aes.doUpdateCMAC(inBuf, 0, 0x30 + blockSize + Integer.reverseBytes(header.dataOffset));
        cmacDataHash = aes.doFinalCMAC();

        if (cmacHeaderHash != header.CMACHeaderHash) {
            return PSP_KIRK_INVALID_HEADER_HASH;
        }

        if (cmacDataHash != header.CMACDataHash) {
            return PSP_KIRK_INVALID_DATA_HASH;
        }

        return 0;
    }

    // Generate SHA1 hash.
    private int executeKIRKCmd11(ByteBuffer out, ByteBuffer in, int size) {
        // Return an error if the crypto engine hasn't been initialized.
        if (!isCryptoEngineInit) {
            return PSP_KIRK_NOT_INIT;
        }

        SHA1Header header = new SHA1Header(in);
        SHA1 sha1 = new SHA1();

        size = (size < header.dataSize) ? size : header.dataSize;
        header.readData(in, size);

        out.clear();
        out.put(sha1.doSHA1(header.data, size));
        in.clear();

        return 0;
    }

    public int hleUtilsBufferCopyWithRange(ByteBuffer out, int outsize, ByteBuffer in, int insize, int cmd) {
        switch (cmd) {
            case PSP_KIRK_CMD_DECRYPT_PRIVATE:
                return executeKIRKCmd1(out, in, insize);
            case PSP_KIRK_CMD_ENCRYPT_IV_0:
                return executeKIRKCmd4(out, in, insize);
            case PSP_KIRK_CMD_DECRYPT_IV_0:
                return executeKIRKCmd7(out, in, insize);
            case PSP_KIRK_CMD_PRIV_SIG_CHECK:
                return executeKIRKCmd10(in, insize);
            case PSP_KIRK_CMD_SHA1_HASH:
                return executeKIRKCmd11(out, in, insize);
            default:
                return PSP_KIRK_INVALID_OPERATION; // Dummy.
        }
    }

    private TAG_INFO GetTagInfo(int tag) {
        int iTag;
        for (iTag = 0; iTag < g_tagInfo.length; iTag++) {
            if (g_tagInfo[iTag].tag == tag) {
                return g_tagInfo[iTag];
            }
        }
        return null;
    }

    private void Scramble(byte[] buf, int size, byte code) {
        // Set CBC mode.
        buf[0] = 0;
        buf[1] = 0;
        buf[2] = 0;
        buf[3] = 5;

        // Set unkown parameters to 0.
        buf[4] = 0;
        buf[5] = 0;
        buf[6] = 0;
        buf[7] = 0;

        buf[8] = 0;
        buf[9] = 0;
        buf[10] = 0;
        buf[11] = 0;

        // Set the the key seed to code.
        buf[12] = 0;
        buf[13] = 0;
        buf[14] = 0;
        buf[15] = code;

        // Set the the data size to size.
        buf[16] = 0;
        buf[17] = 0;
        buf[18] = 0;
        buf[19] = (byte) (size & 0xFF);

        ByteBuffer bBuf = ByteBuffer.wrap(buf);
        hleUtilsBufferCopyWithRange(bBuf, size, bBuf, size, 0x07);
    }

    private void PatchELFTag(byte[] buffer) {
        buffer[0] = 0x7F;
        buffer[1] = 0x45;
        buffer[2] = 0x4C;
        buffer[3] = 0x46;
        buffer[4] = 0x01;
        buffer[5] = 0x01;
        buffer[6] = 0x01;
        buffer[7] = 0x00;
        buffer[8] = 0x00;
        buffer[9] = 0x00;
        buffer[10] = 0x00;
        buffer[11] = 0x00;
        buffer[12] = 0x00;
        buffer[13] = 0x00;
        buffer[14] = 0x00;
        buffer[15] = 0x00;
    }

    public int DecryptPRX2(byte[] inbuf, byte[] outbuf, int size, int tag) {
        // Read the .PRX user tag and find it in the list.
        TAG_INFO pti = GetTagInfo(Integer.reverseBytes(tag));
        if (pti == null) {
            return -1;
        }

        // Check the final ELF size.
        int retsize = ((inbuf[0xB0] & 0xFF) << 24) | ((inbuf[0xB1] & 0xFF) << 16)
                | ((inbuf[0xB2] & 0xFF) << 8) | (inbuf[0xB3] & 0xFF);

        // Setup all buffers.
        byte[] header = new byte[0x150];
        byte[] key = new byte[0x90 + 0x14];
        byte[] sig = new byte[0x60 + 0x14];

        // Fully copy the contents of the encrypted file.
        System.arraycopy(inbuf, 0, outbuf, 0, size);

        // Copy the ~PSP header to header.
        System.arraycopy(outbuf, 0, header, 0, 0x150);

        // Read in the user key and apply scramble.
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 0x10; j++) {
                key[0x14 + ((i << 4) + j)] = (byte) pti.key[j];
            }
            key[0x14 + ((i << 4))] = (byte) i;
        }
        Scramble(key, 0x90, (byte) (pti.code & 0xFF));

        // Regenerate sig check.
        System.arraycopy(header, 0xD0, outbuf, 0, 0x5C);
        System.arraycopy(header, 0x140, outbuf, 0x5C, 0x10);
        System.arraycopy(header, 0x12C, outbuf, 0x6C, 0x14);
        System.arraycopy(header, 0x80, outbuf, 0x80, 0x30);
        System.arraycopy(header, 0xC0, outbuf, 0xB0, 0x10);
        System.arraycopy(header, 0xB0, outbuf, 0xC0, 0x10);
        System.arraycopy(header, 0, outbuf, 0xD0, 0x80);

        // Copy sig check.
        System.arraycopy(outbuf, 0x5C, sig, 0x14, 0x60);

        // Scramble the sig.
        Scramble(sig, 0x60, (byte) (pti.code & 0xFF));

        // Copy the sig again.
        System.arraycopy(sig, 0, outbuf, 0x5C, 0x60);
        System.arraycopy(outbuf, 0x6C, sig, 0, 0x14);
        System.arraycopy(outbuf, 0x5C, outbuf, 0x70, 0x10);
        for (int k = 0; k < 0x58; k++) {
            outbuf[k + 0x18] = 0;
        }
        System.arraycopy(outbuf, 0, outbuf, 0x4, 0x4);

        // Set the SHA1 block size to digest.
        outbuf[0] = 0x00;
        outbuf[1] = 0x00;
        outbuf[2] = 0x01;
        outbuf[3] = 0x4C;
        System.arraycopy(key, 0, outbuf, 0x8, 0x10);

        // Generate SHA1 hash.
        ByteBuffer bSHA1Out = ByteBuffer.wrap(outbuf);
        hleUtilsBufferCopyWithRange(bSHA1Out, size, bSHA1Out, size, 0x0B);

        // Apply XOR calculation on sig.
        for (int iXOR = 0; iXOR < 0x40; iXOR++) {
            sig[iXOR + 0x14] = (byte) (outbuf[iXOR + 0x80] ^ key[iXOR + 0x10]);
        }

        Scramble(sig, 0x40, (byte) (pti.code & 0xFF));

        for (int iXOR = 0x3F; iXOR >= 0; iXOR--) {
            outbuf[iXOR + 0x40] = (byte) (sig[iXOR] ^ key[iXOR + 0x50]);
        }

        for (int k = 0; k < 0x30; k++) {
            outbuf[k + 0x80] = 0;
        }

        // Set mode field to 1.
        outbuf[0xA0] = 0x0;
        outbuf[0xA1] = 0x0;
        outbuf[0xA2] = 0x0;
        outbuf[0xA3] = 0x1;

        System.arraycopy(outbuf, 0xC0, outbuf, 0xB0, 0x10);
        for (int k = 0; k < 0x10; k++) {
            outbuf[k + 0xC0] = 0;
        }

        // Call KIRK CMD1 for final decryption.
        ByteBuffer bDataOut = ByteBuffer.wrap(outbuf);
        ByteBuffer bHeaderIn = bDataOut.duplicate();
        bHeaderIn.position(0x40);
        hleUtilsBufferCopyWithRange(bDataOut, size, bHeaderIn, size, 0x01);

        // Restore first line of ELF data (for JPCSP only).
        PatchELFTag(outbuf);

        if (retsize < 0x150) {
            for (int k = 0; k < (0x150 - retsize); k++) {
                outbuf[k + retsize] = 0;
            }
        }

        return retsize;
    }
}